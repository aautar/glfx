<!DOCTYPE html>
<html>

	<head>

		<style type="text/css">
			* { margin:0; padding:0; }
		</style>
	       
		<script src="../lib/gl-matrix/gl-matrix-min.js" type="text/javascript"></script>
		<script src="../lib/glfx/glfx.js" type="text/javascript"></script>
        <script src="../lib/glfx/scene.js" type="text/javascript"></script>
        
        <script type="text/javascript">

            function wglScene() {
                
                // init 
                var canvasElem = document.getElementById('wgl-canvas');

                glfx.init(canvasElem, 800, 800);

                // Setup scenes and set glfx.renderAllScenes() function describing how scenes are rendered
                var viewportQuadScene = glfx.defaultScene;

                var boxesScene = Object.create(glfx.scene).init();
                boxesScene.setupRenderToTexture();

                var boxesSceneTexture = null;
                glfx.renderAllScenes = function(_time) {
                    boxesSceneTexture = boxesScene.render(_time);
                    viewportQuadScene.render(_time);
                };

                // if we don't do anything further, we'll just be clearing the framebuffer on each frame render
                
                // Load assets for scene
                // Load basic shaders for rendering
                glfx.shaders.load('basic.vs', "vert-shader-basic", glfx.gl.VERTEX_SHADER);
                glfx.shaders.load('basictex.fs', "frag-shader-tex", glfx.gl.FRAGMENT_SHADER);
                glfx.shaders.load('screenspace.fs', "frag-shader-screenspace", glfx.gl.FRAGMENT_SHADER);

                // Load necessary textures
                glfx.textures.load('img/test.png', 'test-tex');					

                // Load models used in scene
                glfx.models.load('cube.json', 'cubemdl', glfx.models.jsonParser);
                
                glfx.whenAssetsLoaded(function() {
                
                
                    var shprog = glfx.shaders.createProgram([glfx.shaders.buffer['vert-shader-basic'], glfx.shaders.buffer['frag-shader-tex']], 
                                                            function(_shprog) {

                                                                // Setup variables for shader program
                                                                _shprog.vertexPositionAttribute = glfx.gl.getAttribLocation(_shprog, "aVertexPosition");
                                                                _shprog.pMatrixUniform = glfx.gl.getUniformLocation(_shprog, "uPMatrix");
                                                                _shprog.mvMatrixUniform = glfx.gl.getUniformLocation(_shprog, "uMVMatrix");
                                                                _shprog.textureCoordAttribute = glfx.gl.getAttribLocation(_shprog, "aTextureCoord");
                                                                 
                                                                glfx.gl.enableVertexAttribArray(_shprog.vertexPositionAttribute);
                                                                glfx.gl.enableVertexAttribArray(_shprog.textureCoordAttribute);

                                                            });


                    var postProcessShaderProgram = glfx.shaders.createProgram([glfx.shaders.buffer['vert-shader-basic'], glfx.shaders.buffer['frag-shader-screenspace']], 
                                                            function(_shprog) {

                                                                // Setup variables for shader program
                                                                _shprog.vertexPositionAttribute = glfx.gl.getAttribLocation(_shprog, "aVertexPosition");
                                                                _shprog.pMatrixUniform = glfx.gl.getUniformLocation(_shprog, "uPMatrix");
                                                                _shprog.mvMatrixUniform = glfx.gl.getUniformLocation(_shprog, "uMVMatrix");
                                                                _shprog.textureCoordAttribute = glfx.gl.getAttribLocation(_shprog, "aTextureCoord");

                                                                _shprog.uPeriod = glfx.gl.getUniformLocation(_shprog, "uPeriod");
                                                                _shprog.uSceneWidth = glfx.gl.getUniformLocation(_shprog, "uSceneWidth");
                                                                _shprog.uSceneHeight = glfx.gl.getUniformLocation(_shprog, "uSceneHeight");
                                                                
                                                                glfx.gl.enableVertexAttribArray(_shprog.vertexPositionAttribute);
                                                                glfx.gl.enableVertexAttribArray(_shprog.textureCoordAttribute);

                                                            });
                                                                              
                                       
                    // add some cubes to the scene graph
                    var cubeA = Object.create(glfx.scene.worldObject);
                    cubeA.init(glfx.models.buffer['cubemdl'], shprog);
                    cubeA.position = vec3.clone([-1.6, 0.0, -25.0]);
                    cubeA.rotation = vec3.clone([0.0, 0.0, 0.0]);
                    cubeA.scale = vec3.clone([0.70, 1.0, 1.0]);
                    cubeA.render = function(tdelta, wobj, matModelView, matPerspective) {
                        // Setup shader program to use
                        var shprog = wobj.shprog;
                        glfx.gl.useProgram(shprog);	

                        var tex = glfx.textures.buffer['test-tex'];				
                        glfx.gl.activeTexture(glfx.gl.TEXTURE0);
                        glfx.gl.bindTexture(glfx.gl.TEXTURE_2D, tex);
                        glfx.gl.uniform1i(shprog.samplerUniform, 0);


                        glfx.gl.bindBuffer(glfx.gl.ARRAY_BUFFER, wobj.base.vertexBuffer);
                        glfx.gl.vertexAttribPointer(shprog.vertexPositionAttribute, wobj.base.vertexBuffer.itemSize, glfx.gl.FLOAT, false, 0, 0);				

                        glfx.gl.bindBuffer(glfx.gl.ARRAY_BUFFER, wobj.base.texcoordBuffer);
                        glfx.gl.vertexAttribPointer(shprog.textureCoordAttribute, wobj.base.texcoordBuffer.itemSize, glfx.gl.FLOAT, false, 0, 0);					

                        glfx.gl.uniformMatrix4fv(shprog.pMatrixUniform, false, matPerspective);
                        glfx.gl.uniformMatrix4fv(shprog.mvMatrixUniform, false, matModelView);				

                        glfx.gl.bindBuffer(glfx.gl.ELEMENT_ARRAY_BUFFER, wobj.base.indexBuffer);
                        glfx.gl.drawElements(glfx.gl.TRIANGLES, wobj.base.indexBuffer.numItems, glfx.gl.UNSIGNED_SHORT, 0);	                        
                    };
                    
                    cubeA.update = function(tdelta, wobj) {
                        
                        // some code to position and spin cubeA
                        wobj.position[2] = -5.0;
                        
                        wobj.rotation[0] = 0.35;
                        wobj.rotation[1] += -(75 * tdelta) / 50000.0;
                        if( Math.abs(wobj.rotation[1]) >= 2.0*Math.PI ) {
                            wobj.rotation[1] = 0.0;
                        }                 
                    };
              


                    // Add another cube to the scene
                    var cubeB = Object.create(glfx.scene.worldObject);
                    cubeB.init(glfx.models.buffer['cubemdl'], shprog);
                    cubeB.position = vec3.clone([1.6, 0.0, -25.0]);
                    cubeB.rotation = vec3.clone([0.0, 0.0, 0.0]);
                    cubeB.scale = vec3.clone([0.70, 1.0, 1.0]);
                    cubeB.update = function(tdelta, wobj) {
                        // some code to position and spin cubeB
                         wobj.position[2] = -15.0;
                       
                        wobj.rotation[0] = 0.35;
                        wobj.rotation[1] += -(75 * tdelta) / 50000.0;
                        if( Math.abs(wobj.rotation[1]) >= 2.0*Math.PI ) {
                            wobj.rotation[1] = 0.0;
                        }                   
                    };
                    
                    cubeB.render = function(tdelta, wobj, matModelView, matPerspective) {
                        // Setup shader program to use
                        var shprog = wobj.shprog;
                        glfx.gl.useProgram(shprog);	

                        var tex = glfx.textures.buffer['test-tex'];				
                        glfx.gl.activeTexture(glfx.gl.TEXTURE0);
                        glfx.gl.bindTexture(glfx.gl.TEXTURE_2D, tex);
                        glfx.gl.uniform1i(shprog.samplerUniform, 0);


                        glfx.gl.bindBuffer(glfx.gl.ARRAY_BUFFER, wobj.base.vertexBuffer);
                        glfx.gl.vertexAttribPointer(shprog.vertexPositionAttribute, wobj.base.vertexBuffer.itemSize, glfx.gl.FLOAT, false, 0, 0);				

                        glfx.gl.bindBuffer(glfx.gl.ARRAY_BUFFER, wobj.base.texcoordBuffer);
                        glfx.gl.vertexAttribPointer(shprog.textureCoordAttribute, wobj.base.texcoordBuffer.itemSize, glfx.gl.FLOAT, false, 0, 0);					

                        glfx.gl.uniformMatrix4fv(shprog.pMatrixUniform, false, matPerspective);
                        glfx.gl.uniformMatrix4fv(shprog.mvMatrixUniform, false, matModelView);				

                        glfx.gl.bindBuffer(glfx.gl.ELEMENT_ARRAY_BUFFER, wobj.base.indexBuffer);
                        glfx.gl.drawElements(glfx.gl.TRIANGLES, wobj.base.indexBuffer.numItems, glfx.gl.UNSIGNED_SHORT, 0);	                        
                    };

                    boxesScene.addWorldObject( cubeA );
                    boxesScene.addWorldObject( cubeB );

                    var quad = Object.create(glfx.scene.screenObject);
                    quad.init(glfx.models.buffer['rttquad'], postProcessShaderProgram);
                    quad.timeAcc = 0;
                    quad.timeScaled = 0;

                    quad.update = function(tdelta, screenObj) {
                        quad.timeAcc += tdelta;
                        quad.timeScaled = quad.timeAcc * 0.00107;

                        if(quad.timeScaled > 2.0*Math.PI) {
                            quad.timeScaled = 0;
                            quad.timeAcc = 0;
                        }
                    };

                    quad.render = function(tdelta, screenObj, matModelView, matPerspective) {

                        var shprog = screenObj.shprog;
                        glfx.gl.useProgram(shprog);

                        var tex = boxesSceneTexture;

                        glfx.gl.activeTexture(glfx.gl.TEXTURE0);
                        glfx.gl.bindTexture(glfx.gl.TEXTURE_2D, tex);
                        glfx.gl.uniform1i(shprog.samplerUniform, 0);

                        glfx.gl.bindBuffer(glfx.gl.ARRAY_BUFFER, screenObj.base.vertexBuffer);
                        glfx.gl.vertexAttribPointer(shprog.vertexPositionAttribute, screenObj.base.vertexBuffer.itemSize, glfx.gl.FLOAT, false, 0, 0);

                        glfx.gl.bindBuffer(glfx.gl.ARRAY_BUFFER, screenObj.base.texcoordBuffer);
                        glfx.gl.vertexAttribPointer(shprog.textureCoordAttribute, screenObj.base.texcoordBuffer.itemSize, glfx.gl.FLOAT, false, 0, 0);

                        glfx.gl.uniformMatrix4fv(shprog.pMatrixUniform, false, matPerspective);
                        glfx.gl.uniformMatrix4fv(shprog.mvMatrixUniform, false, matModelView);

                        glfx.gl.bindBuffer(glfx.gl.ELEMENT_ARRAY_BUFFER, screenObj.base.indexBuffer);

                        var period = Math.cos(quad.timeScaled);
                        glfx.gl.uniform1f(postProcessShaderProgram.uPeriod, period + 1.0);
                        glfx.gl.uniform1f(postProcessShaderProgram.uSceneWidth, glfx.gl.viewportWidth);
                        glfx.gl.uniform1f(postProcessShaderProgram.uSceneHeight, glfx.gl.viewportHeight);

                        glfx.gl.drawElements(glfx.gl.TRIANGLE_STRIP, screenObj.base.indexBuffer.numItems, glfx.gl.UNSIGNED_SHORT, 0);
                    };

                    viewportQuadScene.addScreenObject(quad);

                });
                
                
            }
            
        </script>
        
	</head>
	
	<body onload="wglScene();" style="overflow:hidden;">
	
		<div>
			<canvas id="wgl-canvas" style="width:800px; height:800px; overflow:hidden;" width="800" height="800"></canvas>
		</div>
		
	</body>

</html>